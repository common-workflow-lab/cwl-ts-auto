
import {
  Dictionary,
  expandUrl,
  loadField,
  LoaderInstances,
  LoadingOptions,
  Saveable,
  ValidationException,
  prefixUrl,
  save,
  saveRelativeUri
} from './util/internal'
import { v4 as uuidv4 } from 'uuid'
import * as Internal from './util/internal'


/**
 * Auto-generated class implementation for https://w3id.org/cwl/cwl#CommandOutputBinding
 *
 * Describes how to generate an output parameter based on the files produced
 * by a CommandLineTool.
 * 
 * The output parameter value is generated by applying these operations in the
 * following order:
 * 
 *   - glob
 *   - loadContents
 *   - outputEval
 *   - secondaryFiles
 * 
 */
export class CommandOutputBinding extends Saveable implements Internal.CommandOutputBindingProperties {
  extensionFields?: Internal.Dictionary<any>

  /**
   * Only valid when `type: File` or is an array of `items: File`.
   * 
   * If true, the file (or each file in the array) must be a UTF-8
   * text file 64 KiB or smaller, and the implementation must read
   * the entire contents of the file (or file array) and place it
   * in the `contents` field of the File object for use by
   * expressions.  If the size of the file is greater than 64 KiB,
   * the implementation must raise a fatal error.
   * 
   */
  loadContents?: undefined | boolean

  /**
   * Only valid when `type: Directory` or is an array of `items: Directory`.
   * 
   * Specify the desired behavior for loading the `listing` field of
   * a Directory object for use by expressions.
   * 
   * The order of precedence for loadListing is:
   * 
   *   1. `loadListing` on an individual parameter
   *   2. Inherited from `LoadListingRequirement`
   *   3. By default: `no_listing`
   * 
   */
  loadListing?: undefined | string

  /**
   * Find files or directories relative to the output directory, using POSIX
   * glob(3) pathname matching.  If an array is provided, find files or
   * directories that match any pattern in the array.  If an expression is
   * provided, the expression must return a string or an array of strings,
   * which will then be evaluated as one or more glob patterns.  Must only
   * match and return files/directories which actually exist.
   * 
   * If the value of glob is a relative path pattern (does not
   * begin with a slash '/') then it is resolved relative to the
   * output directory.  If the value of the glob is an absolute
   * path pattern (it does begin with a slash '/') then it must
   * refer to a path within the output directory.  It is an error
   * if any glob resolves to a path outside the output directory.
   * Specifically this means globs that resolve to paths outside the output
   * directory are illegal.
   * 
   * A glob may match a path within the output directory which is
   * actually a symlink to another file.  In this case, the
   * expected behavior is for the resulting File/Directory object to take the
   * `basename` (and corresponding `nameroot` and `nameext`) of the
   * symlink.  The `location` of the File/Directory is implementation
   * dependent, but logically the File/Directory should have the same content
   * as the symlink target.  Platforms may stage output files/directories to
   * cloud storage that lack the concept of a symlink.  In
   * this case file content and directories may be duplicated, or (to avoid
   * duplication) the File/Directory `location` may refer to the symlink
   * target.
   * 
   * It is an error if a symlink in the output directory (or any
   * symlink in a chain of links) refers to any file or directory
   * that is not under an input or output directory.
   * 
   * Implementations may shut down a container before globbing
   * output, so globs and expressions must not assume access to the
   * container filesystem except for declared input and output.
   * 
   */
  glob?: undefined | string | Array<string>

  /**
   * Evaluate an expression to generate the output value.  If
   * `glob` was specified, the value of `self` must be an array
   * containing file objects that were matched.  If no files were
   * matched, `self` must be a zero length array; if a single file
   * was matched, the value of `self` is an array of a single
   * element.  The exit code of the process is
   * available in the expression as `runtime.exitCode`.
   * 
   * Additionally if `loadContents` is true, the file must be a
   * UTF-8 text file 64 KiB or smaller, and the implementation must
   * read the entire contents of the file (or file array) and place
   * it in the `contents` field of the File object for use in
   * `outputEval`.  If the size of the file is greater than 64 KiB,
   * the implementation must raise a fatal error.
   * 
   * If a tool needs to return a large amount of structured data to
   * the workflow, loading the output object from `cwl.output.json`
   * bypasses `outputEval` and is not subject to the 64 KiB
   * `loadContents` limit.
   * 
   */
  outputEval?: undefined | string


  constructor ({loadingOptions, extensionFields, loadContents, loadListing, glob, outputEval} : {loadingOptions?: LoadingOptions} & Internal.CommandOutputBindingProperties) {
    super(loadingOptions)
    this.extensionFields = extensionFields ?? {}
    this.loadContents = loadContents
    this.loadListing = loadListing
    this.glob = glob
    this.outputEval = outputEval
  }

  /**
   * Used to construct instances of {@link CommandOutputBinding }.
   *
   * @param __doc                           Document fragment to load this record object from.
   * @param baseuri                         Base URI to generate child document IDs against.
   * @param loadingOptions                  Context for loading URIs and populating objects.
   * @param docRoot                         ID at this position in the document (if available)
   * @returns                               An instance of {@link CommandOutputBinding }
   * @throws {@link ValidationException}    If the document fragment is not a
   *                                        {@link Dictionary} or validation of fields fails.
   */
  static override async fromDoc (__doc: any, baseuri: string, loadingOptions: LoadingOptions,
    docRoot?: string): Promise<Saveable> {
    const _doc = Object.assign({}, __doc)
    const __errors: ValidationException[] = []
            
    let loadContents
    if ('loadContents' in _doc) {
      try {
        loadContents = await loadField(_doc.loadContents, LoaderInstances.unionOfundefinedtypeOrbooltype,
          baseuri, loadingOptions)
      } catch (e) {
        if (e instanceof ValidationException) {
          __errors.push(
            new ValidationException('the `loadContents` field is not valid because: ', [e])
          )
        } else {
          throw e
        }
      }
    }

    let loadListing
    if ('loadListing' in _doc) {
      try {
        loadListing = await loadField(_doc.loadListing, LoaderInstances.unionOfundefinedtypeOrLoadListingEnumLoader,
          baseuri, loadingOptions)
      } catch (e) {
        if (e instanceof ValidationException) {
          __errors.push(
            new ValidationException('the `loadListing` field is not valid because: ', [e])
          )
        } else {
          throw e
        }
      }
    }

    let glob
    if ('glob' in _doc) {
      try {
        glob = await loadField(_doc.glob, LoaderInstances.unionOfundefinedtypeOrstrtypeOrExpressionLoaderOrarrayOfstrtype,
          baseuri, loadingOptions)
      } catch (e) {
        if (e instanceof ValidationException) {
          __errors.push(
            new ValidationException('the `glob` field is not valid because: ', [e])
          )
        } else {
          throw e
        }
      }
    }

    let outputEval
    if ('outputEval' in _doc) {
      try {
        outputEval = await loadField(_doc.outputEval, LoaderInstances.unionOfundefinedtypeOrExpressionLoader,
          baseuri, loadingOptions)
      } catch (e) {
        if (e instanceof ValidationException) {
          __errors.push(
            new ValidationException('the `outputEval` field is not valid because: ', [e])
          )
        } else {
          throw e
        }
      }
    }

    const extensionFields: Dictionary<any> = {}
    for (const [key, value] of Object.entries(_doc)) {
      if (!CommandOutputBinding.attr.has(key)) {
        if ((key as string).includes(':')) {
          const ex = expandUrl(key, '', loadingOptions, false, false)
          extensionFields[ex] = value
        } else {
          __errors.push(
            new ValidationException(`invalid field ${key as string}, \
            expected one of: \`loadContents\`,\`loadListing\`,\`glob\`,\`outputEval\``)
          )
          break
        }
      }
    }

    if (__errors.length > 0) {
      throw new ValidationException("Trying 'CommandOutputBinding'", __errors)
    }

    const schema = new CommandOutputBinding({
      extensionFields: extensionFields,
      loadingOptions: loadingOptions,
      loadContents: loadContents,
      loadListing: loadListing,
      glob: glob,
      outputEval: outputEval
    })
    return schema
  }
        
  save (top: boolean = false, baseUrl: string = '', relativeUris: boolean = true)
  : Dictionary<any> {
    const r: Dictionary<any> = {}
    for (const ef in this.extensionFields) {
      r[prefixUrl(ef, this.loadingOptions.vocab)] = this.extensionFields.ef
    }

    if (this.loadContents != null) {
      r.loadContents = save(this.loadContents, false, baseUrl, relativeUris)
    }
                
    if (this.loadListing != null) {
      r.loadListing = save(this.loadListing, false, baseUrl, relativeUris)
    }
                
    if (this.glob != null) {
      r.glob = save(this.glob, false, baseUrl, relativeUris)
    }
                
    if (this.outputEval != null) {
      r.outputEval = save(this.outputEval, false, baseUrl, relativeUris)
    }
                
    if (top) {
      if (this.loadingOptions.namespaces != null) {
        r.$namespaces = this.loadingOptions.namespaces
      }
      if (this.loadingOptions.schemas != null) {
        r.$schemas = this.loadingOptions.schemas
      }
    }
    return r
  }
            
  static attr: Set<string> = new Set(['loadContents','loadListing','glob','outputEval'])
}
